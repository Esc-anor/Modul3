Модуль_3_1
    Цель: применить на практике начальные знания о пространстве имён и оператор global. Закрепить навыки из предыдущих модулей.
    
    Задача "Счётчик вызовов":
    Порой необходимо отслеживать, сколько раз вызывалась та или иная функция. К сожалению, в Python не предусмотрен подсчёт вызовов автоматически.
    Давайте реализуем данную фишку самостоятельно!
    
    Вам необходимо написать 3 функции:
    Функция count_calls подсчитывающая вызовы остальных функций.
    Функция string_info принимает аргумент - строку и возвращает кортеж из: длины этой строки, строку в верхнем регистре, строку в нижнем регистре.
    Функция is_contains принимает два аргумента: строку и список, и возвращает True, если строка находится в этом списке, False - если отсутствует. Регистром строки при проверке пренебречь: UrbaN ~ URBAN.
    Пункты задачи:
    Создать переменную calls = 0 вне функций.
    Создать функцию count_calls и изменять в ней значение переменной calls. Эта функция должна вызываться в остальных двух функциях.
    Создать функцию string_info с параметром string и реализовать логику работы по описанию.
    Создать функцию is_contains с двумя параметрами string и list_to_search, реализовать логику работы по описанию.
    Вызвать соответствующие функции string_info и is_contains произвольное кол-во раз с произвольными данными.
    Вывести значение переменной calls на экран(в консоль).
    
    Пример результата выполнения программы:
    Пример выполняемого кода:
    print(string_info('Capybara'))
    print(string_info('Armageddon'))
    print(is_contains('Urban', ['ban', 'BaNaN', 'urBAN'])) # Urban ~ urBAN
    print(is_contains('cycle', ['recycling', 'cyclic'])) # No matches
    print(calls)
    Вывод на консоль:
    (8, 'CAPYBARA', 'capybara')
    (10, 'ARMAGEDDON', 'armageddon')
    True
    False
    4
    Примечания:
    Для использования глобальной переменной внутри функции используйте оператор global.
    Для функции is_contains лучше привести и искомую строку и все строки в списке в один регистр.
    Файл module_3_1.py и загрузите его на ваш GitHub репозиторий. В решении пришлите ссылку на него.

Модуль_3_2
    Цель: закрепить знания о параметрах по умолчанию и именованных аргументах.

    Задача "Рассылка писем":
    Часто при разработке и работе с рассылками писем(e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях.
    Попробуем реализовать функцию с подробной логикой.
    
    Создайте функцию send_email, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.
    Внутри функции реализовать следующую логику:
    Проверка на корректность e-mail отправителя и получателя.
    Проверка на отправку самому себе.
    Проверка на отправителя по умолчанию.
    Пункты задачи:
    Создайте функцию send_email, которая принимает 2 обычных аргумента: message(сообщение), recipient(получатель) и 1 обязательно именованный аргумент со значением по умолчанию sender = "university.help@gmail.com".
    Если строки recipient и sender не содержит "@" или не оканчивается на ".com"/".ru"/".net", то вывести на экран(в консоль) строку: "Невозможно отправить письмо с адреса <sender> на адрес <recipient>".
    Если же sender и recipient совпадают, то вывести "Нельзя отправить письмо самому себе!"
    Если же отправитель по умолчанию - university.help@gmail.com, то вывести сообщение: "Письмо успешно отправлено с адреса <sender> на адрес <recipient>."
    В противном случае вывести сообщение: "НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса <sender> на адрес <recipient>."
    Здесь <sender> и <recipient> - значения хранящиеся в этих переменных.
    За один вызов функции выводится только одно и перечисленных уведомлений! Проверки перечислены по мере выполнения.
    
    Пример результата выполнения программы:
    Пример выполняемого кода (тесты):
    send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
    send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
    send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
    send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')
    Вывод на консоль:
    Письмо успешно отправлено с адреса university.help@gmail.com на адрес vasyok1337@gmail.com
    НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса urban.info@gmail.com на адрес urban.fan@mail.ru
    Невозможно отправить письмо с адреса urban.teacher@mail.uk на адрес urban.student@mail.ru
    Нельзя отправить письмо самому себе!
    
    Примечания:
    Обязательно именованные аргументы отделяются от остальных символом "*" перед ними.
    Именованные аргументы всегда идут после позиционных.

Модуль_3_3
    Цель задания: Освоить создание функций с параметрами по умолчанию и практику вызова этих функций с различным количеством аргументов.

    Задача "Распаковка":
    1.Функция с параметрами по умолчанию:
    Создайте функцию print_params(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: 1, 'строка', True).
    Функция должна выводить эти параметры.
    Вызовите функцию print_params с разным количеством аргументов, включая вызов без аргументов.
    Проверьте, работают ли вызовы print_params(b = 25) print_params(c = [1,2,3])
    2.Распаковка параметров:
    Создайте список values_list с тремя элементами разных типов.
    Создайте словарь values_dict с тремя ключами, соответствующими параметрам функции print_params, и значениями разных типов.
    Передайте values_list и values_dict в функцию print_params, используя распаковку параметров (* для списка и ** для словаря).
    3.Распаковка + отдельные параметры:
    Создайте список values_list_2 с двумя элементами разных типов
    Проверьте, работает ли print_params(*values_list_2, 42)
    Пример результата выполнения программы:
    Исходный код:
    values_list_2 = [54.32, 'Строка' ]
    print_params(*values_list_2, 42)
    Вывод на консоль:
    54.32 'Строка' 42
    
    Примечания:
    Использование параметров по умолчанию позволяет функциям быть гибкими и удобными в использовании.
    Распаковка параметров из списка и словаря позволяет передавать группы значений в функцию, что упрощает работу с данными.
    Важно!
    Не передавайте списки задавая по умолчанию пустой список или другой изменяемый тип данных!
    В таком случае, если этот список будет изменён внутри функции, то на следующий вызов функции он останется в том же состоянии.
    def a(my_list = [])) – это приводит к ошибкам!
    
    Можно передавать вот так(список создаётся локально, мы не влияем на его изменение вне функции)
    def append_to_list(item, list_my=None):
      if list_my is None:
       list_my = []
      list_my.append(item)
    print(list_my)
    
    Файл module_3_3.py и загрузите его на ваш GitHub репозиторий. В решении пришлите ссылку на него.

Модуль_3_4
    Цель: закрепить знание использования параметров *args/ **kwargs на практике.
    
    Задача "Однокоренные":
    Напишите функцию single_root_words, которая принимает одно обязательное слово в параметр root_word, а далее неограниченную последовательность в параметр *other_words.
    Функция должна составить новый список same_words только из тех слов списка other_words, которые содержат root_word или наоборот root_word содержит одно из этих слов. После вернуть список same_words в качестве результата своей работы.
    
    Пункты задачи:
    Объявите функцию single_root_words и напишите в ней параметры root_word и *other_words.
    Создайте внутри функции пустой список same_words, который пополнится нужными словами.
    При помощи цикла for переберите предполагаемо подходящие слова.
    Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список same_words.
    После цикла верните образованный функцией список same_words.
    Вызовите функцию single_root_words и выведете на экран(консоль) возвращённое ей значение.
    Пример результата выполнения программы:
    Исходный код:
    result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')
    result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')
    print(result1)
    print(result2)
    Вывод на консоль:
    ['richiest', 'orichalcum', 'richies']
    ['Able', 'Disable']
    Примечания:
    При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. ('Disablement' - 'Able') ('Able', 'able', 'AbLe' - все подходят)
    В этой задаче вам могут понадобиться следующие методы строк/ключевые слова:
    а. Оператор in или count()
    b. lower()/upper().

Модуль_3_5
    Цель: применить знания о рекурсии в решении задачи.

    Задача "Рекурсивное умножение цифр":
    Напиши функцию get_multiplied_digits, которая принимает аргумент целое число number и подсчитывает произведение цифр этого числа.
    
    Пункты задачи:
    Напишите функцию get_multiplied_digits и параметр number в ней.
    Создайте переменную str_number и запишите строковое представление(str) числа number в неё.
    Основной задачей будет отделение первой цифры в числе: создайте переменную first и запишите в неё первый символ из str_number в числовом представлении(int).
    Возвращайте значение first * get_multiplied_digits(int(str_number[1:])). Таким образом вы умножите первую цифру числа на результат работы этой же функции с числом, но уже без первой цифры.
    4 пункт можно выполнить только тогда, когда длина str_number больше 1, т.к. в противном случае не получиться взять срез str_number[1:].
    Если же длина str_number не больше 1, тогда вернуть оставшуюся цифру first.
    Стек вызовов будет выглядеть следующим образом:
    get_multiplied_digits(40203) -> 4 * get_multiplied_digits(203) -> 4 * 2 * get_multiplied_digits(3) -> 4 * 2 * 3
    
    Пример результата выполнения программы:
    Исходный код:
    result = get_multiplied_digits(40203)
    print(result)
    Вывод на консоль:
    24
    
    Примечания:
    При преобразовании строки(str) в число(int) первые нули убираются. int('00123') -> 123.
    Если возникает ошибка, рекомендуется пошагово отладить программу "жучком". Чаще всего ошибка заключается в бесконечной рекурсии или же в неверном обращении по индексу.

*Дополнительное практическое задание по модулю: "Подробнее о функциях."
    
    Цель: Применить знания полученные в модуле, решив задачу повышенного уровня сложности
    
    
    Задание "Раз, два, три, четыре, пять .... Это не всё?":
    Наши студенты, без исключения, - очень умные ребята. Настолько умные, что иногда по утру сами путаются в том, что намудрили вчера вечером.
    Один из таких учеников уснул на клавиатуре в процессе упорной учёбы (ещё и трудолюбивые). Тем не менее, даже после сна, его код остался рабочим и выглядел следующим образом:
    
    data_structure = [
      [1, 2, 3],
      {'a': 4, 'b': 5},
      (6, {'cube': 7, 'drum': 8}),
      "Hello",
      ((), [{(2, 'Urban', ('Urban2', 35))}])
    ]
    
    Увидев это студент задался вопросом: "А есть ли универсальное решение для подсчёта суммы всех чисел и длин всех строк?"
    Да, выглядит страшно, да и обращаться нужно к каждой внутренней структуре (списку, словарю и т.д.) по-разному.
    
    Ученику пришлось каждый раз использовать индексацию и обращение по ключам - универсального решения для таких структур он не нашёл.
    
    Помогите сокурснику осуществить его задумку.
    
    Что должно быть подсчитано:
    Все числа (не важно, являются они ключами или значениям или ещё чем-то).
    Все строки (не важно, являются они ключами или значениям или ещё чем-то)
    
    Для примера, указанного выше, расчёт вёлся следующим образом:
    1 + 2 + 3 + len('a') + 4 + len('b') + 5 + 6 + len('cube') + 7 + .... + 35 = 99
    
    Входные данные (применение функции):
    data_structure = [
    [1, 2, 3],
    {'a': 4, 'b': 5},
    (6, {'cube': 7, 'drum': 8}),
    "Hello",
    ((), [{(2, 'Urban', ('Urban2', 35))}])
    ]
    
    result = calculate_structure_sum(data_structure)
    print(result)
    
    
    Выходные данные (консоль):
    99
    
    
    Примечания (рекомендации):
    Весь подсчёт должен выполняться одним вызовом функции.
    Рекомендуется применить рекурсивный вызов функции, для каждой внутренней структуры.
    Т.к. каждая структура может содержать в себе ещё несколько элементов, можно использовать параметр *args
    Для определения типа данного используйте функцию isinstance.
    
    Файл с кодом (module_3_hard.py) прикрепите к домашнему заданию или пришлите ссылку на ваш GitHub репозиторий с файлом решения.
    
    Успехов!
