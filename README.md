Модуль_3_1
    Цель: применить на практике начальные знания о пространстве имён и оператор global. Закрепить навыки из предыдущих модулей.
    
    Задача "Счётчик вызовов":
    Порой необходимо отслеживать, сколько раз вызывалась та или иная функция. К сожалению, в Python не предусмотрен подсчёт вызовов автоматически.
    Давайте реализуем данную фишку самостоятельно!
    
    Вам необходимо написать 3 функции:
    Функция count_calls подсчитывающая вызовы остальных функций.
    Функция string_info принимает аргумент - строку и возвращает кортеж из: длины этой строки, строку в верхнем регистре, строку в нижнем регистре.
    Функция is_contains принимает два аргумента: строку и список, и возвращает True, если строка находится в этом списке, False - если отсутствует. Регистром строки при проверке пренебречь: UrbaN ~ URBAN.
    Пункты задачи:
    Создать переменную calls = 0 вне функций.
    Создать функцию count_calls и изменять в ней значение переменной calls. Эта функция должна вызываться в остальных двух функциях.
    Создать функцию string_info с параметром string и реализовать логику работы по описанию.
    Создать функцию is_contains с двумя параметрами string и list_to_search, реализовать логику работы по описанию.
    Вызвать соответствующие функции string_info и is_contains произвольное кол-во раз с произвольными данными.
    Вывести значение переменной calls на экран(в консоль).
    
    Пример результата выполнения программы:
    Пример выполняемого кода:
    print(string_info('Capybara'))
    print(string_info('Armageddon'))
    print(is_contains('Urban', ['ban', 'BaNaN', 'urBAN'])) # Urban ~ urBAN
    print(is_contains('cycle', ['recycling', 'cyclic'])) # No matches
    print(calls)
    Вывод на консоль:
    (8, 'CAPYBARA', 'capybara')
    (10, 'ARMAGEDDON', 'armageddon')
    True
    False
    4
    Примечания:
    Для использования глобальной переменной внутри функции используйте оператор global.
    Для функции is_contains лучше привести и искомую строку и все строки в списке в один регистр.
    Файл module_3_1.py и загрузите его на ваш GitHub репозиторий. В решении пришлите ссылку на него.

Модуль_3_2
    Цель: закрепить знания о параметрах по умолчанию и именованных аргументах.

    Задача "Рассылка писем":
    Часто при разработке и работе с рассылками писем(e-mail) они отправляются от одного и того же пользователя(администрации или службы поддержки). Тем не менее должна быть возможность сменить его в редких случаях.
    Попробуем реализовать функцию с подробной логикой.
    
    Создайте функцию send_email, которая принимает 2 обычных аргумента: сообщение и получатель и 1 обязательно именованный аргумент со значением по умолчанию - отправитель.
    Внутри функции реализовать следующую логику:
    Проверка на корректность e-mail отправителя и получателя.
    Проверка на отправку самому себе.
    Проверка на отправителя по умолчанию.
    Пункты задачи:
    Создайте функцию send_email, которая принимает 2 обычных аргумента: message(сообщение), recipient(получатель) и 1 обязательно именованный аргумент со значением по умолчанию sender = "university.help@gmail.com".
    Если строки recipient и sender не содержит "@" или не оканчивается на ".com"/".ru"/".net", то вывести на экран(в консоль) строку: "Невозможно отправить письмо с адреса <sender> на адрес <recipient>".
    Если же sender и recipient совпадают, то вывести "Нельзя отправить письмо самому себе!"
    Если же отправитель по умолчанию - university.help@gmail.com, то вывести сообщение: "Письмо успешно отправлено с адреса <sender> на адрес <recipient>."
    В противном случае вывести сообщение: "НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса <sender> на адрес <recipient>."
    Здесь <sender> и <recipient> - значения хранящиеся в этих переменных.
    За один вызов функции выводится только одно и перечисленных уведомлений! Проверки перечислены по мере выполнения.
    
    Пример результата выполнения программы:
    Пример выполняемого кода (тесты):
    send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
    send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
    send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
    send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')
    Вывод на консоль:
    Письмо успешно отправлено с адреса university.help@gmail.com на адрес vasyok1337@gmail.com
    НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса urban.info@gmail.com на адрес urban.fan@mail.ru
    Невозможно отправить письмо с адреса urban.teacher@mail.uk на адрес urban.student@mail.ru
    Нельзя отправить письмо самому себе!
    
    Примечания:
    Обязательно именованные аргументы отделяются от остальных символом "*" перед ними.
    Именованные аргументы всегда идут после позиционных.

Модуль_3_3
    Цель задания: Освоить создание функций с параметрами по умолчанию и практику вызова этих функций с различным количеством аргументов.

    Задача "Распаковка":
    1.Функция с параметрами по умолчанию:
    Создайте функцию print_params(a = 1, b = 'строка', c = True), которая принимает три параметра со значениями по умолчанию (например сейчас это: 1, 'строка', True).
    Функция должна выводить эти параметры.
    Вызовите функцию print_params с разным количеством аргументов, включая вызов без аргументов.
    Проверьте, работают ли вызовы print_params(b = 25) print_params(c = [1,2,3])
    2.Распаковка параметров:
    Создайте список values_list с тремя элементами разных типов.
    Создайте словарь values_dict с тремя ключами, соответствующими параметрам функции print_params, и значениями разных типов.
    Передайте values_list и values_dict в функцию print_params, используя распаковку параметров (* для списка и ** для словаря).
    3.Распаковка + отдельные параметры:
    Создайте список values_list_2 с двумя элементами разных типов
    Проверьте, работает ли print_params(*values_list_2, 42)
    Пример результата выполнения программы:
    Исходный код:
    values_list_2 = [54.32, 'Строка' ]
    print_params(*values_list_2, 42)
    Вывод на консоль:
    54.32 'Строка' 42
    
    Примечания:
    Использование параметров по умолчанию позволяет функциям быть гибкими и удобными в использовании.
    Распаковка параметров из списка и словаря позволяет передавать группы значений в функцию, что упрощает работу с данными.
    Важно!
    Не передавайте списки задавая по умолчанию пустой список или другой изменяемый тип данных!
    В таком случае, если этот список будет изменён внутри функции, то на следующий вызов функции он останется в том же состоянии.
    def a(my_list = [])) – это приводит к ошибкам!
    
    Можно передавать вот так(список создаётся локально, мы не влияем на его изменение вне функции)
    def append_to_list(item, list_my=None):
      if list_my is None:
       list_my = []
      list_my.append(item)
    print(list_my)
    
    Файл module_3_3.py и загрузите его на ваш GitHub репозиторий. В решении пришлите ссылку на него.

Модуль_3_4
    Цель: закрепить знание использования параметров *args/ **kwargs на практике.
    
    Задача "Однокоренные":
    Напишите функцию single_root_words, которая принимает одно обязательное слово в параметр root_word, а далее неограниченную последовательность в параметр *other_words.
    Функция должна составить новый список same_words только из тех слов списка other_words, которые содержат root_word или наоборот root_word содержит одно из этих слов. После вернуть список same_words в качестве результата своей работы.
    
    Пункты задачи:
    Объявите функцию single_root_words и напишите в ней параметры root_word и *other_words.
    Создайте внутри функции пустой список same_words, который пополнится нужными словами.
    При помощи цикла for переберите предполагаемо подходящие слова.
    Пропишите корректное относительно задачи условие, при котором добавляются слова в результирующий список same_words.
    После цикла верните образованный функцией список same_words.
    Вызовите функцию single_root_words и выведете на экран(консоль) возвращённое ей значение.
    Пример результата выполнения программы:
    Исходный код:
    result1 = single_root_words('rich', 'richiest', 'orichalcum', 'cheers', 'richies')
    result2 = single_root_words('Disablement', 'Able', 'Mable', 'Disable', 'Bagel')
    print(result1)
    print(result2)
    Вывод на консоль:
    ['richiest', 'orichalcum', 'richies']
    ['Able', 'Disable']
    Примечания:
    При проверке наличия одного слова в составе другого стоит учесть, что регистр символов не должен влиять ни на что. ('Disablement' - 'Able') ('Able', 'able', 'AbLe' - все подходят)
    В этой задаче вам могут понадобиться следующие методы строк/ключевые слова:
    а. Оператор in или count()
    b. lower()/upper().

Модуль_3_5
    
